{
    "description": "Tracked all project files including new grok_local structure' with current x_poller.py content",
    "timestamp": "2025-03-04T00:09:33.413897",
    "files": [
        "grok_bootstrap.py"
    ],
    "current_task": "",
    "chat_address": "34ab8f53-7308-4b4c-898a-cc136b017aa4",
    "chat_group": "default",
    "file_content": "import os\nimport time\nimport logging\nimport subprocess\nimport argparse\nfrom dotenv import load_dotenv\nfrom browser_use import Agent  # For real X interaction\n\nPROJECT_DIR = os.getcwd()\nLAST_CMD_FILE = os.path.join(PROJECT_DIR, \"last_processed.txt\")\nLOG_FILE = os.path.join(PROJECT_DIR, \"x_poller.log\")\n\nlogger = logging.getLogger('x_poller_main')\nlogger.handlers.clear()\nlogger.propagate = False\nfile_handler = logging.FileHandler(LOG_FILE)\nfile_handler.setFormatter(logging.Formatter(\"%(asctime)s - %(levelname)s - %(message)s\"))\nconsole_handler = logging.StreamHandler()\nconsole_handler.setFormatter(logging.Formatter(\"%(asctime)s - %(levelname)s - %(message)s\"))\nlogger.addHandler(file_handler)\nlogger.addHandler(console_handler)\n\nload_dotenv()\nX_USERNAME = os.getenv(\"X_USERNAME\")\nX_PASSWORD = os.getenv(\"X_PASSWORD\")\nX_VERIFY = os.getenv(\"X_VERIFY\")\n\ndef x_login(headless=True, stub=False):\n    \"\"\"Log into X using Browser-Use, falling back to stub if credentials missing or stub mode enabled.\"\"\"\n    logger.info(\"Attempting X login\")\n    if stub or not all([X_USERNAME, X_PASSWORD]):\n        logger.debug(f\"Checking stub credentials: username={X_USERNAME}, password={'*' * len(X_PASSWORD) if X_PASSWORD else None}, verify={X_VERIFY}\")\n        time.sleep(2)\n        if all([X_USERNAME, X_PASSWORD, X_VERIFY]):\n            logger.info(\"Stubbed login simulation successful\")\n            print(\"Stubbed login successful\")\n            return True\n        logger.info(\"Stubbed login simulation failed: missing credentials\")\n        return False\n    \n    try:\n        # Simplified Agent instantiation; adjust based on browser-use docs\n        agent = Agent(headless=headless)  # No 'model' parameter\n        agent.navigate(\"https://x.com/login\")\n        # Assuming fill_form takes a dict of field names to values\n        agent.fill_form({\"username\": X_USERNAME, \"password\": X_PASSWORD})\n        agent.submit_form()\n        time.sleep(2)\n        # Check if login succeeded (agent.current_url might be current_url())\n        if \"login\" not in agent.current_url():\n            logger.info(\"Successfully logged into X via Browser-Use\")\n            return agent\n        else:\n            logger.error(\"X login failed: Still on login page\")\n            return None\n    except Exception as e:\n        logger.error(f\"X login error with Browser-Use: {str(e)}\")\n        return None\n\ndef scan_grok_chat(agent):\n    if not agent or agent is True:\n        return simulate_chat_scan()\n    try:\n        agent.navigate(\"https://x.com/i/grok\")\n        chat_content = agent.extract_text(selector=\".grok-chat-container\")\n        logger.debug(f\"Scanned chat content: {chat_content}\")\n        return chat_content.split(\"\\n\") if chat_content else []\n    except Exception as e:\n        logger.error(f\"Chat scan error: {str(e)}\")\n        return []\n\ndef simulate_chat_scan():\n    logger.debug(\"Simulating chat scan\")\n    time.sleep(0.5)\n    mock_content = [\"GROK_LOCAL: git status\", \"Hello world\", \"Test message\"]\n    logger.debug(f\"Mock chat content: {mock_content}\")\n    logger.info(f\"Simulated chat scan returned {len(mock_content)} lines\")\n    return mock_content\n\ndef ask_grok(prompt, fetch=False, headless=False, use_stub=False):\n    logger.debug(f\"Entering ask_grok with prompt: {prompt}, fetch: {fetch}, headless: {headless}, use_stub: {use_stub}\")\n    if use_stub or not all([X_USERNAME, X_PASSWORD]):\n        if x_login(stub=True):\n            if fetch:\n                chat_content = simulate_chat_scan()\n                return process_grok_interaction(prompt, fetch, chat_content=chat_content)\n            logger.debug(\"Simulating prompt submission\")\n            return \"Prompt submitted (stubbed)\"\n        return \"Stubbed login failed\"\n    \n    agent = x_login(headless)\n    if not agent:\n        return \"Login failed\"\n    try:\n        agent.navigate(\"https://x.com/i/grok\")\n        agent.fill_form({\"message\": prompt}, selector=\".grok-input-field\")\n        agent.submit_form()\n        time.sleep(2)\n        response = agent.extract_text(selector=\".grok-response\")\n        logger.info(f\"Grok 3 response to '{prompt}': {response}\")\n        return response if response else \"No response received\"\n    except Exception as e:\n        logger.error(f\"Grok interaction error: {str(e)}\")\n        return f\"Error: {str(e)}\"\n    finally:\n        agent.close()\n\ndef process_grok_interaction(prompt, fetch, chat_content=None):\n    logger.debug(f\"Processing interaction - fetch: {fetch}, prompt: {prompt}\")\n    if fetch:\n        if chat_content is None:\n            logger.error(\"Chat content missing\")\n            return \"Error: No chat content\"\n        commands = []\n        for text in reversed(chat_content):\n            if \"GROK_LOCAL:\" in text.upper() and \"GROK_LOCAL_RESULT:\" not in text.upper():\n                cmd = text.replace(\"GROK_LOCAL:\", \"\").strip()\n                valid_commands = [\"what time is it?\", \"ask what time is it\", \"list files\", \"system info\", \"commit\", \"whoami\", \"scan chat\", \"git status\"]\n                if cmd.lower().startswith(\"commit \") or cmd.lower() in valid_commands:\n                    commands.append(cmd)\n                    logger.info(f\"Found command: {cmd}\")\n        if not commands:\n            logger.info(\"No GROK_LOCAL commands found\")\n            return \"No GROK_LOCAL found after full scan\"\n        logger.debug(f\"All commands found (in reverse order): {commands}\")\n        last_command = commands[0]\n        logger.info(f\"Selected last command: {last_command}\")\n        return last_command\n    logger.debug(\"Prompt submitted (non-fetch mode)\")\n    return \"Prompt submitted\"\n\ndef poll_x(headless, debug=False, info=False, poll_interval=5, stub=False):\n    logger.debug(\"Entering poll_x\")\n    logger.info(\"Starting polling loop\")\n    last_processed = None\n    if os.path.exists(LAST_CMD_FILE):\n        try:\n            with open(LAST_CMD_FILE, \"r\") as f:\n                last_processed = f.read().strip()\n            logger.info(f\"Last processed command from file: {last_processed}\")\n        except Exception as e:\n            logger.error(f\"Failed to read {LAST_CMD_FILE}: {e}\")\n    while True:\n        logger.debug(\"Starting poll iteration\")\n        agent = x_login(headless, stub=stub)\n        if agent is True:\n            cmd = ask_grok(\"Polling for Grok 3...\", fetch=True, headless=headless, use_stub=True)\n        else:\n            chat_content = scan_grok_chat(agent)\n            cmd = process_grok_interaction(\"Polling for Grok 3...\", fetch=True, chat_content=chat_content)\n        if cmd and isinstance(cmd, str) and \"Error\" not in cmd and \"login failed\" not in cmd.lower():\n            if cmd != last_processed:\n                logger.info(f\"Executing command: {cmd}\")\n                try:\n                    result = subprocess.run(\n                        [\"python\", \"grok_local.py\", \"--ask\", cmd],\n                        capture_output=True, text=True, timeout=5\n                    )\n                    output = result.stdout.strip() if result.stdout else f\"Error: {result.stderr}\"\n                    logger.info(f\"Command result: {output}\")\n                    if agent and agent is not True:\n                        ask_grok(f\"GROK_LOCAL_RESULT: {output}\", headless=headless)\n                except subprocess.TimeoutExpired as e:\n                    output = f\"Timeout: {e.stderr.decode() if e.stderr else 'No error output'}\"\n                    logger.error(f\"Command timed out: {cmd}\")\n                with open(LAST_CMD_FILE, \"w\") as f:\n                    f.write(cmd)\n                last_processed = cmd\n        if agent and agent is not True:\n            agent.close()\n        time.sleep(poll_interval)\n\nif __name__ == \"__main__\":\n    parser = argparse.ArgumentParser(\n        description=\"X Poller: Poll X for Grok 3 commands and execute them via grok_local.\\n\\n\"\n                    \"This script polls an X chat for GROK_LOCAL commands (e.g., 'GROK_LOCAL: git status'), \"\n                    \"executes them using grok_local.py, and posts results back as 'GROK_LOCAL_RESULT: <output>'. \",\n        epilog=\"Environment Variables:\\n\"\n               \"  X_USERNAME: X account username\\n\"\n               \"  X_PASSWORD: X account password\\n\"\n               \"  X_VERIFY: X verification code (optional for stub mode)\\n\\n\"\n               \"Examples:\\n\"\n               \"  python x_poller.py --headless          # Run silently\\n\"\n               \"  python x_poller.py --stub --test       # Test stub mode\\n\"\n               \"  python x_poller.py --headless --debug  # Show debug logs\",\n        formatter_class=argparse.RawDescriptionHelpFormatter\n    )\n    parser.add_argument(\"--headless\", action=\"store_true\", help=\"Run Chrome in headless mode\")\n    parser.add_argument(\"--stub\", action=\"store_true\", help=\"Run in stub mode without real X interaction\")\n    parser.add_argument(\"--test\", action=\"store_true\", help=\"Run a single stubbed login test and exit\")\n    parser.add_argument(\"--debug\", \"-d\", action=\"store_true\", help=\"Enable debug logging\")\n    parser.add_argument(\"--info\", \"-i\", action=\"store_true\", help=\"Enable info logging\")\n    parser.add_argument(\"--poll-interval\", type=float, default=5, help=\"Set polling interval in seconds\")\n    args = parser.parse_args()\n\n    if args.debug:\n        logger.setLevel(logging.DEBUG)\n        file_handler.setLevel(logging.DEBUG)\n        console_handler.setLevel(logging.DEBUG)\n    elif args.info:\n        logger.setLevel(logging.INFO)\n        file_handler.setLevel(logging.INFO)\n        console_handler.setLevel(logging.INFO)\n    else:\n        logger.setLevel(logging.WARNING)\n        file_handler.setLevel(logging.WARNING)\n        console_handler.setLevel(logging.WARNING)\n\n    if args.test:\n        x_login(stub=args.stub)\n    else:\n        poll_x(args.headless, debug=args.debug, info=args.info, poll_interval=args.poll_interval, stub=args.stub)\n"
}