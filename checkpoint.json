{
    "description": "Added clean safe command",
    "timestamp": "2025-02-27T09:16:50.482174",
    "files": {
        "grok_local.py": "import os\nimport sys\nimport argparse\nimport datetime\nimport logging\nimport json\nfrom logging.handlers import RotatingFileHandler\nfrom file_ops import create_file, delete_file, move_file, copy_file, read_file, write_file, list_files, rename_file\nfrom git_ops import git_status, git_pull, git_log, git_branch, git_checkout, git_commit_and_push, git_rm, git_diff\n\nPROJECT_DIR = os.getcwd()\nLOG_FILE = os.path.join(PROJECT_DIR, \"grok_local.log\")\nCHECKPOINT_FILE = os.path.join(PROJECT_DIR, \"checkpoint.json\")\nSAFE_DIR = os.path.join(PROJECT_DIR, \"safe\")\n\nlogging.basicConfig(\n    level=logging.INFO,\n    format=\"%(asctime)s - %(levelname)s - %(message)s\",\n    handlers=[RotatingFileHandler(LOG_FILE, maxBytes=1*1024*1024, backupCount=3)]\n)\nlogger = logging.getLogger(__name__)\n\nCRITICAL_FILES = [\n    \"grok_local.py\", \"file_ops.py\", \"git_ops.py\", \"grok_checkpoint.py\",\n    \".gitignore\", \"grok.txt\", \"tests/test_grok_local.py\", \"README.md\"\n]\n\ndef ensure_safe_dir():\n    \"\"\"Create SAFE_DIR if it doesn\u2019t exist.\"\"\"\n    if not os.path.exists(SAFE_DIR):\n        os.makedirs(SAFE_DIR)\n        logger.info(f\"Created safe directory: {SAFE_DIR}\")\n\ndef load_checkpoint(filename=None):\n    checkpoint_file = filename if filename else CHECKPOINT_FILE\n    if os.path.exists(checkpoint_file):\n        with open(checkpoint_file, \"r\") as f:\n            return json.load(f)\n    return {}\n\ndef save_checkpoint(description, filename=None):\n    checkpoint = {\n        \"description\": description,\n        \"timestamp\": datetime.datetime.now().isoformat(),\n        \"files\": {},\n        \"safe_files\": {}\n    }\n    for fname in CRITICAL_FILES:\n        file_path = os.path.join(PROJECT_DIR, fname)\n        if os.path.exists(file_path):\n            with open(file_path, \"r\") as f:\n                checkpoint[\"files\"][fname] = f.read()\n        else:\n            checkpoint[\"files\"][fname] = \"File not found\"\n    if os.path.exists(SAFE_DIR):\n        for fname in os.listdir(SAFE_DIR):\n            file_path = os.path.join(SAFE_DIR, fname)\n            if os.path.isfile(file_path):\n                with open(file_path, \"r\") as f:\n                    checkpoint[\"safe_files\"][fname] = f.read()\n    checkpoint_file = filename if filename else CHECKPOINT_FILE\n    with open(checkpoint_file, \"w\") as f:\n        json.dump(checkpoint, f, indent=4)\n    logger.info(f\"Saved checkpoint with description: {description} to {checkpoint_file}\")\n    return f\"Checkpoint saved: {description} to {checkpoint_file}\"\n\ndef restore_checkpoint(all_files=False, filename=None):\n    checkpoint = load_checkpoint(filename)\n    if not checkpoint:\n        return f\"No checkpoint found to restore at {filename or CHECKPOINT_FILE}\"\n    safe_files = checkpoint.get(\"safe_files\", {})\n    critical_files = checkpoint.get(\"files\", {}) if all_files else {}\n    if not (safe_files or critical_files):\n        return \"No files to restore in checkpoint\"\n    restored = []\n    ensure_safe_dir()\n    for fname, content in safe_files.items():\n        file_path = os.path.join(SAFE_DIR, fname)\n        if os.path.exists(file_path):\n            os.remove(file_path)\n        with open(file_path, \"w\") as f:\n            f.write(content)\n        logger.debug(f\"Restored safe file: {fname}\")\n        restored.append(fname)\n    if all_files:\n        for fname, content in critical_files.items():\n            if content != \"File not found\":\n                file_path = os.path.join(PROJECT_DIR, fname)\n                if os.path.exists(file_path):\n                    os.remove(file_path)\n                with open(file_path, \"w\") as f:\n                    f.write(content)\n                logger.debug(f\"Restored critical file: {fname}\")\n                restored.append(fname)\n    logger.info(f\"Restored files from checkpoint: {restored}\")\n    return f\"Restored files from checkpoint: {', '.join(restored)}\"\n\ndef list_checkpoints():\n    checkpoints = []\n    for fname in os.listdir(PROJECT_DIR):\n        if fname.endswith(\".json\"):\n            file_path = os.path.join(PROJECT_DIR, fname)\n            try:\n                with open(file_path, \"r\") as f:\n                    checkpoint = json.load(f)\n                    desc = checkpoint.get(\"description\", \"No description\")\n                    time = checkpoint.get(\"timestamp\", \"Unknown\")\n                    checkpoints.append(f\"{fname}: {desc} ({time})\")\n            except json.JSONDecodeError:\n                continue\n    if not checkpoints:\n        return \"No checkpoints found\"\n    logger.info(\"Listed available checkpoints\")\n    return \"\\n\".join(checkpoints)\n\ndef clean_safe(keep=None):\n    \"\"\"Clean safe/ directory, optionally keeping specified files.\"\"\"\n    if not os.path.exists(SAFE_DIR):\n        return \"Safe directory is already empty\"\n    deleted = []\n    keep_files = set(keep.split(\",\")) if keep else set()\n    for fname in os.listdir(SAFE_DIR):\n        if fname in keep_files:\n            continue\n        file_path = os.path.join(SAFE_DIR, fname)\n        if os.path.isfile(file_path):\n            os.remove(file_path)\n            deleted.append(fname)\n            logger.debug(f\"Deleted file from safe/: {fname}\")\n    logger.info(f\"Cleaned safe/, deleted: {deleted}\")\n    return f\"Cleaned safe/, deleted: {', '.join(deleted) if deleted else 'nothing'}\"\n\ndef report_to_grok(response):\n    return response\n\ndef what_time_is_it():\n    now = datetime.datetime.now(datetime.timezone.utc)\n    time_str = now.strftime(\"%I:%M %p GMT, %B %d, %Y\")\n    logger.info(f\"Time requested: {time_str}\")\n    return time_str\n\ndef process_multi_command(request):\n    commands = request.split(\"&&\")\n    results = []\n    for cmd in commands:\n        cmd = cmd.strip()\n        if not cmd:\n            continue\n        result = ask_local(cmd)\n        results.append(result)\n    logger.info(f\"Processed multi-command: {request}\")\n    return \"\\n\".join(results)\n\ndef ask_local(request, debug=False):\n    request = request.strip().rstrip(\"?\")\n    if \"&&\" in request:\n        result = process_multi_command(request)\n        if any(r.startswith(\"Error\") or r.startswith(\"Git\") for r in result.split(\"\\n\")):\n            save_checkpoint(f\"Multi-command failed: {request}\")\n        return result\n    \n    req_lower = request.lower()\n    if req_lower in [\"what time is it\", \"ask what time is it\"]:\n        result = report_to_grok(what_time_is_it())\n        return result\n    elif req_lower == \"list files\":\n        result = report_to_grok(list_files())\n        return result\n    elif req_lower.startswith(\"commit \"):\n        message = request[7:].strip() or \"Automated commit\"\n        result = report_to_grok(git_commit_and_push(message))\n        if result.startswith(\"Git error\"):\n            save_checkpoint(f\"Commit failed: {result}\")\n        return result\n    elif req_lower == \"git status\":\n        result = report_to_grok(git_status())\n        return result\n    elif req_lower == \"git pull\":\n        result = report_to_grok(git_pull())\n        if \"error\" in result.lower():\n            save_checkpoint(f\"Git pull failed: {result}\")\n        return result\n    elif req_lower.startswith(\"git log\"):\n        count = request[7:].strip()\n        count = int(count) if count.isdigit() else 1\n        result = report_to_grok(git_log(count))\n        if result.startswith(\"Git error\"):\n            save_checkpoint(f\"Git log failed: {result}\")\n        return result\n    elif req_lower == \"git branch\":\n        result = report_to_grok(git_branch())\n        if result.startswith(\"Git error\"):\n            save_checkpoint(f\"Git branch failed: {result}\")\n        return result\n    elif req_lower.startswith(\"git checkout \"):\n        branch = request[12:].strip()\n        result = report_to_grok(git_checkout(branch))\n        if result.startswith(\"Git error\"):\n            save_checkpoint(f\"Git checkout failed: {result}\")\n        return result\n    elif req_lower.startswith(\"git rm \"):\n        filename = request[6:].strip()\n        result = report_to_grok(git_rm(filename))\n        if result.startswith(\"Git error\"):\n            save_checkpoint(f\"Git rm failed: {result}\")\n        return result\n    elif req_lower == \"git diff\":\n        result = report_to_grok(git_diff())\n        return result\n    elif req_lower == \"list checkpoints\":\n        result = report_to_grok(list_checkpoints())\n        return result\n    elif req_lower.startswith(\"clean safe\"):\n        parts = request.split(maxsplit=2)\n        keep = parts[2] if len(parts) > 2 and parts[2].startswith(\"--keep \") else None\n        keep = keep[len(\"--keep \"):] if keep else None\n        result = report_to_grok(clean_safe(keep))\n        return result\n    elif req_lower.startswith(\"create file \"):\n        filename = request[11:].strip()\n        result = report_to_grok(create_file(filename))\n        if result.startswith(\"Error\"):\n            save_checkpoint(f\"Create file failed: {result}\")\n        return result\n    elif req_lower.startswith(\"delete file \"):\n        parts = request[11:].strip().split(\" --force\")\n        filename = parts[0].strip().replace(\"safe/\", \"\")\n        force = len(parts) > 1 and \"--force\" in request.lower()\n        result = report_to_grok(delete_file(filename, force))\n        if result.startswith(\"Error\"):\n            save_checkpoint(f\"Delete file failed: {result}\")\n        return result\n    elif req_lower.startswith(\"move file\"):\n        parts = request[9:].strip().split(\" to \")\n        if len(parts) != 2:\n            logger.error(\"Invalid move command format\")\n            result = \"Error: Invalid move command format. Use 'move file <src> to <dst>'\"\n            save_checkpoint(f\"Move file failed: {result}\")\n            return result\n        src, dst = parts\n        result = report_to_grok(move_file(src.strip().replace(\"safe/\", \"\"), dst.strip().replace(\"safe/\", \"\")))\n        if result.startswith(\"Error\"):\n            save_checkpoint(f\"Move file failed: {result}\")\n        return result\n    elif req_lower.startswith(\"copy file \"):\n        parts = request[9:].strip().split(\" to \")\n        if len(parts) != 2:\n            logger.error(\"Invalid copy command format\")\n            result = \"Error: Invalid copy command format. Use 'move file <src> to <dst>'\"\n            save_checkpoint(f\"Copy file failed: {result}\")\n            return result\n        src, dst = parts\n        result = report_to_grok(copy_file(src.strip().replace(\"safe/\", \"\"), dst.strip().replace(\"safe/\", \"\")))\n        if result.startswith(\"Error\"):\n            save_checkpoint(f\"Copy file failed: {result}\")\n        return result\n    elif req_lower.startswith(\"rename file \"):\n        parts = request[11:].strip().split(\" to \")\n        if len(parts) != 2:\n            logger.error(\"Invalid rename command format\")\n            result = \"Error: Invalid rename command format. Use 'rename file <old> to <new>'\"\n            save_checkpoint(f\"Rename file failed: {result}\")\n            return result\n        src, dst = parts\n        result = report_to_grok(rename_file(src.strip().replace(\"safe/\", \"\"), dst.strip().replace(\"safe/\", \"\")))\n        if result.startswith(\"Error\"):\n            save_checkpoint(f\"Rename file failed: {result}\")\n        return result\n    elif req_lower.startswith(\"read file \"):\n        filename = request[9:].strip().replace(\"safe/\", \"\")\n        result = report_to_grok(read_file(filename))\n        if result.startswith(\"Error\"):\n            save_checkpoint(f\"Read file failed: {result}\")\n        return result\n    elif req_lower.startswith(\"write \"):\n        parts = request[5:].strip().split(\" to \")\n        if len(parts) != 2:\n            logger.error(\"Invalid write command format\")\n            result = \"Error: Invalid write command format. Use 'write <content> to <filename>'\"\n            save_checkpoint(f\"Write file failed: {result}\")\n            return result\n        content, filename = parts\n        result = report_to_grok(write_file(filename.strip().replace(\"safe/\", \"\"), content.strip()))\n        if result.startswith(\"Error\"):\n            save_checkpoint(f\"Write file failed: {result}\")\n        return result\n    elif req_lower.startswith(\"checkpoint \"):\n        parts = request.split()\n        description_idx = 1 if parts[0].lower() == \"checkpoint\" else 0\n        if \"--file\" in parts:\n            try:\n                file_idx = parts.index(\"--file\")\n                filename = parts[file_idx + 1] if file_idx + 1 < len(parts) else None\n                description = \" \".join(parts[description_idx:file_idx])\n            except (ValueError, IndexError):\n                return \"Error: --file requires a valid filename\"\n        else:\n            filename = None\n            description = \" \".join(parts[description_idx:])\n        if not description:\n            return \"Error: Checkpoint requires a description\"\n        return save_checkpoint(description, filename)\n    elif req_lower.startswith(\"restore\"):\n        parts = request.split()\n        all_files = \"--all\" in parts\n        filename = None\n        if \"--file\" in parts:\n            try:\n                file_idx = parts.index(\"--file\") + 1\n                filename = parts[file_idx] if file_idx < len(parts) else None\n            except ValueError:\n                return \"Error: --file requires a filename\"\n        return restore_checkpoint(all_files, filename)\n    else:\n        logger.warning(f\"Unknown command received: {request}\")\n        result = f\"Unknown command: {request}\"\n        save_checkpoint(f\"Unknown command: {request}\")\n        return result\n\nif __name__ == \"__main__\":\n    parser = argparse.ArgumentParser(description=\"Local Grok Agent\")\n    parser.add_argument(\"--ask\", type=str, help=\"Command to execute\")\n    parser.add_argument(\"--resume\", action=\"store_true\", help=\"Display last checkpoint\")\n    parser.add_argument(\"--debug\", action=\"store_true\", help=\"Enable debug output\")\n    parser.add_argument(\"--all\", action=\"store_true\", help=\"Restore all files from checkpoint (including critical)\")\n    parser.add_argument(\"--file\", type=str, help=\"Specify checkpoint file to save/restore from\")\n    args = parser.parse_args()\n\n    if args.resume:\n        checkpoint = load_checkpoint()\n        if checkpoint:\n            desc = checkpoint.get(\"description\", \"No description\")\n            time = checkpoint.get(\"timestamp\", \"Unknown\")\n            files = checkpoint.get(\"files\", {})\n            safe_files = checkpoint.get(\"safe_files\", {})\n            print(f\"Last Checkpoint:\\n- Description: {desc}\\n- Timestamp: {time}\\n- Files tracked: {', '.join(files.keys())}\")\n            if safe_files:\n                print(f\"- Safe files: {', '.join(safe_files.keys())}\")\n        else:\n            print(\"No checkpoint found.\")\n    elif args.ask:\n        print(ask_local(args.ask, args.debug))\n    else:\n        while True:\n            cmd = input(\"Command: \")\n            if cmd.lower() == \"exit\":\n                break\n            print(ask_local(cmd, args.debug))\n",
        "file_ops.py": "import os\nimport shutil\nimport re\nimport logging\n\nPROJECT_DIR = os.getcwd()\nSAFE_DIR = os.path.join(PROJECT_DIR, \"safe\")\nlogger = logging.getLogger(__name__)\n\nCRITICAL_FILES = {\"grok_local.py\", \"x_poller.py\", \".gitignore\"}\n\ndef sanitize_filename(filename):\n    \"\"\"Ensure filename is safe and within SAFE_DIR.\"\"\"\n    filename = re.sub(r'[<>:\"/\\|?*]', '', filename.strip())\n    full_path = os.path.join(SAFE_DIR, filename)\n    if not full_path.startswith(SAFE_DIR + os.sep):\n        logger.error(f\"Invalid filename attempt: {filename}\")\n        return None\n    if os.path.basename(filename) in CRITICAL_FILES:\n        logger.error(f\"Protected file access denied: {filename}\")\n        return None\n    return filename\n\ndef ensure_safe_dir():\n    \"\"\"Create SAFE_DIR if it doesn\u2019t exist.\"\"\"\n    if not os.path.exists(SAFE_DIR):\n        os.makedirs(SAFE_DIR)\n        logger.info(f\"Created safe directory: {SAFE_DIR}\")\n\ndef create_file(filename):\n    ensure_safe_dir()\n    filename = sanitize_filename(filename)\n    if not filename:\n        return \"Error: Invalid or protected filename\"\n    try:\n        with open(os.path.join(SAFE_DIR, filename), \"w\") as f:\n            f.write(\"\")\n        logger.info(f\"Created file: {filename}\")\n        return f\"Created file: {filename}\"\n    except Exception as e:\n        logger.error(f\"Error creating file {filename}: {e}\")\n        return f\"Error creating file: {e}\"\n\ndef delete_file(filename, force=False):\n    ensure_safe_dir()\n    filename = sanitize_filename(filename)\n    if not filename:\n        return \"Error: Invalid or protected filename\"\n    full_path = os.path.join(SAFE_DIR, filename)\n    if not os.path.exists(full_path):\n        logger.warning(f\"File not found for deletion: {filename}\")\n        return f\"File not found: {filename}\"\n    if not force and \"y\" != input(f\"Confirm deletion of {filename}? (y/n): \").lower():\n        logger.info(f\"Deletion of {filename} cancelled\")\n        return f\"Deletion cancelled: {filename}\"\n    try:\n        os.remove(full_path)\n        logger.info(f\"Deleted file: {filename}\")\n        return f\"Deleted file: {filename}\"\n    except Exception as e:\n        logger.error(f\"Error deleting file {filename}: {e}\")\n        return f\"Error deleting file: {e}\"\n\ndef move_file(src, dst):\n    ensure_safe_dir()\n    src = sanitize_filename(src)\n    dst = sanitize_filename(dst)\n    if not (src and dst):\n        return \"Error: Invalid or protected filename\"\n    src_path = os.path.join(SAFE_DIR, src)\n    dst_path = os.path.join(SAFE_DIR, dst)\n    if not os.path.exists(src_path):\n        logger.warning(f\"Source file not found: {src}\")\n        return f\"Source file not found: {src}\"\n    try:\n        shutil.move(src_path, dst_path)\n        logger.info(f\"Moved {src} to {dst}\")\n        return f\"Moved {src} to {dst}\"\n    except Exception as e:\n        logger.error(f\"Error moving file {src} to {dst}: {e}\")\n        return f\"Error moving file: {e}\"\n\ndef copy_file(src, dst):\n    ensure_safe_dir()\n    src = sanitize_filename(src)\n    dst = sanitize_filename(dst)\n    if not (src and dst):\n        return \"Error: Invalid or protected filename\"\n    src_path = os.path.join(SAFE_DIR, src)\n    dst_path = os.path.join(SAFE_DIR, dst)\n    if not os.path.exists(src_path):\n        logger.warning(f\"Source file not found: {src}\")\n        return f\"Source file not found: {src}\"\n    try:\n        shutil.copy(src_path, dst_path)\n        logger.info(f\"Copied {src} to {dst}\")\n        return f\"Copied {src} to {dst}\"\n    except Exception as e:\n        logger.error(f\"Error copying file {src} to {dst}: {e}\")\n        return f\"Error copying file: {e}\"\n\ndef rename_file(src, dst):\n    return move_file(src, dst)  # Alias move for clarity\n\ndef read_file(filename):\n    ensure_safe_dir()\n    filename = sanitize_filename(filename)\n    if not filename:\n        return \"Error: Invalid or protected filename\"\n    full_path = os.path.join(SAFE_DIR, filename)\n    if not os.path.exists(full_path):\n        logger.warning(f\"File not found for reading: {filename}\")\n        return f\"File not found: {filename}\"\n    try:\n        with open(full_path, \"r\") as f:\n            content = f.read()\n        logger.info(f\"Read file: {filename}\")\n        return f\"Content of {filename}: {content}\"\n    except Exception as e:\n        logger.error(f\"Error reading file {filename}: {e}\")\n        return f\"Error reading file: {e}\"\n\ndef write_file(filename, content):\n    ensure_safe_dir()\n    filename = sanitize_filename(filename)\n    if not filename:\n        return \"Error: Invalid or protected filename\"\n    full_path = os.path.join(SAFE_DIR, filename)\n    try:\n        with open(full_path, \"w\") as f:\n            f.write(content)\n        logger.info(f\"Wrote to {filename}: {content}\")\n        return f\"Wrote to {filename}: {content}\"\n    except Exception as e:\n        logger.error(f\"Error writing file {filename}: {e}\")\n        return f\"Error writing file: {e}\"\n\ndef list_files():\n    ensure_safe_dir()\n    try:\n        files = os.listdir(SAFE_DIR)\n        logger.info(\"Listed files in safe directory\")\n        if not files:\n            return \"No files in safe directory\"\n        return \"\\n\".join(f\"{i+1}. {file}\" for i, file in enumerate(files))\n    except Exception as e:\n        logger.error(f\"Error listing files: {e}\")\n        return f\"Error listing files: {e}\"\n",
        "git_ops.py": "import os\nimport git\nfrom git import Repo\nimport logging\n\nPROJECT_DIR = os.getcwd()\nlogger = logging.getLogger(__name__)\n\ndef git_status():\n    try:\n        repo = Repo(PROJECT_DIR)\n        status = repo.git.status()\n        logger.info(\"Retrieved git status\")\n        return status\n    except Exception as e:\n        logger.error(f\"Git status error: {e}\")\n        return f\"Git status error: {e}\"\n\ndef git_pull():\n    try:\n        repo = Repo(PROJECT_DIR)\n        repo.git.pull()\n        logger.info(\"Pulled latest changes\")\n        return \"Pulled latest changes\"\n    except Exception as e:\n        logger.error(f\"Git pull error: {e}\")\n        return f\"Git pull error: {e}\"\n\ndef git_log(count=1):\n    try:\n        repo = Repo(PROJECT_DIR)\n        log = repo.git.log(f\"-{count}\")\n        logger.info(f\"Retrieved git log with count {count}\")\n        return log\n    except Exception as e:\n        logger.error(f\"Git log error: {e}\")\n        return f\"Git log error: {e}\"\n\ndef git_branch():\n    try:\n        repo = Repo(PROJECT_DIR)\n        branches = repo.git.branch()\n        logger.info(\"Listed git branches\")\n        return branches\n    except Exception as e:\n        logger.error(f\"Git branch error: {e}\")\n        return f\"Git branch error: {e}\"\n\ndef git_checkout(branch):\n    try:\n        repo = Repo(PROJECT_DIR)\n        repo.git.checkout(branch)\n        logger.info(f\"Checked out branch: {branch}\")\n        return f\"Checked out branch: {branch}\"\n    except Exception as e:\n        logger.error(f\"Git checkout error: {e}\")\n        return f\"Git checkout error: {e}\"\n\ndef git_commit_and_push(message=\"Automated commit\"):\n    repo = Repo(PROJECT_DIR)\n    try:\n        repo.git.add(A=True)\n        status = repo.git.status()\n        if \"nothing to commit\" in status:\n            logger.info(\"Nothing to commit\")\n            return \"Nothing to commit\"\n        repo.git.commit(m=message)\n        repo.git.push()\n        logger.info(f\"Committed and pushed: {message}\")\n        return f\"Committed and pushed: {message}\"\n    except git.GitCommandError as e:\n        logger.error(f\"Git error: {e}\")\n        return f\"Git error: {str(e)}\"\n\ndef git_rm(filename):\n    try:\n        repo = Repo(PROJECT_DIR)\n        repo.git.rm(filename)\n        logger.info(f\"Removed file from git: {filename}\")\n        return f\"Removed file from git: {filename}\"\n    except git.GitCommandError as e:\n        logger.error(f\"Git rm error for {filename}: {e}\")\n        return f\"Git rm error: {str(e)}\"\n\ndef git_diff():\n    try:\n        repo = Repo(PROJECT_DIR)\n        diff = repo.git.diff()\n        if not diff:\n            logger.info(\"No changes to display in git diff\")\n            return \"No changes to display\"\n        logger.info(\"Retrieved git diff\")\n        return diff\n    except Exception as e:\n        logger.error(f\"Git diff error: {e}\")\n        return f\"Git diff error: {e}\"\n",
        "grok_checkpoint.py": "import os\nimport subprocess\nimport sys\n\nPROJECT_DIR = os.path.dirname(os.path.abspath(__file__))\nos.chdir(PROJECT_DIR)\n\ndef start_session(command=None, resume=False):\n    \"\"\"Start a grok-local session, either interactive, with a command, or resuming.\"\"\"\n    args = [\"python\", \"grok_local.py\"]\n    if resume:\n        args.append(\"--resume\")\n    elif command:\n        if command.startswith(\"--ask \"):\n            args.append(\"--ask\")\n            args.append(command[6:].strip())\n        else:\n            args.append(command)\n    result = subprocess.run(\n        args,\n        capture_output=True,\n        text=True\n    )\n    print(result.stdout.strip())\n    if result.stderr:\n        print(f\"Error: {result.stderr.strip()}\", file=sys.stderr)\n\nif __name__ == \"__main__\":\n    if len(sys.argv) > 1:\n        if \"--resume\" in sys.argv:\n            start_session(resume=True)\n        else:\n            command = \" \".join(sys.argv[1:])\n            start_session(command=command)\n    else:\n        start_session()\n",
        ".gitignore": "misc/\n*.log\n*.log.*\ncookies.pkl\n__pycache__/\ndebug/\ncode_blocks/\nlast_processed.txt\n.DS_Store\nsafe/\n",
        "grok.txt": "I am Grok, master of the repo",
        "tests/test_grok_local.py": "import os\nimport subprocess\nimport sys\nimport json\nimport shutil\n\n# Ensure we're in the project root\nPROJECT_DIR = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))\nos.chdir(PROJECT_DIR)\nsys.path.append(PROJECT_DIR)\n\nfrom grok_local import ask_local, ensure_safe_dir\n\ndef run_command(cmd, use_subprocess=False):\n    \"\"\"Run a command either via ask_local or subprocess.\"\"\"\n    if use_subprocess:\n        result = subprocess.run(\n            [\"python\", \"grok_checkpoint.py\", \"--ask\", cmd],\n            capture_output=True, text=True\n        )\n        return result.stdout.strip()\n    else:\n        return ask_local(cmd)\n\ndef test_sequence():\n    print(\"Starting test sequence...\")\n    safe_dir = os.path.join(PROJECT_DIR, \"safe\")\n\n    # Clean slate\n    if os.path.exists(safe_dir):\n        shutil.rmtree(safe_dir)\n\n    # Test 1: Create a file\n    result = run_command(\"create file test1.txt\")\n    print(f\"Create file: {result}\")\n    assert \"Created file: test1.txt\" in result, \"File creation failed\"\n\n    # Test 2: Write to the file\n    result = run_command(\"write Hello, Grok! to test1.txt\")\n    print(f\"Write to file: {result}\")\n    assert \"Wrote to test1.txt: Hello, Grok!\" in result, \"File write failed\"\n\n    # Test 3: Read the file\n    result = run_command(\"read file test1.txt\")\n    print(f\"Read file: {result}\")\n    assert \"Content of test1.txt: Hello, Grok!\" in result, \"File read failed\"\n\n    # Test 4: Delete with force\n    result = run_command(\"delete file test1.txt --force\")\n    print(f\"Delete with force: {result}\")\n    assert \"Deleted file: test1.txt\" in result, \"Forced delete failed\"\n\n    # Test 5: Git status\n    result = run_command(\"git status\")\n    print(f\"Git status: {result}\")\n    assert \"On branch\" in result, \"Git status failed\"\n\n    # Test 6: Multi-command\n    result = run_command(\"create file test2.txt && write Test2 to test2.txt\")\n    print(f\"Multi-command: {result}\")\n    assert \"Created file: test2.txt\" in result and \"Wrote to test2.txt: Test2\" in result, \"Multi-command failed\"\n\n    # Test 7: Checkpoint\n    result = run_command(\"checkpoint Test checkpoint with test2.txt\")\n    print(f\"Checkpoint: {result}\")\n    assert \"Checkpoint saved: Test checkpoint with test2.txt\" in result, \"Checkpoint failed\"\n    with open(os.path.join(PROJECT_DIR, \"checkpoint.json\"), \"r\") as f:\n        checkpoint = json.load(f)\n    assert checkpoint[\"description\"] == \"Test checkpoint with test2.txt\", \"Checkpoint description mismatch\"\n    assert \"grok_local.py\" in checkpoint[\"files\"], \"Checkpoint missing critical files\"\n    assert \"test2.txt\" in checkpoint[\"safe_files\"], \"Checkpoint missing safe files\"\n\n    # Test 8: Empty safe directory\n    shutil.rmtree(safe_dir)\n    result = run_command(\"list files\")\n    print(f\"List empty safe/: {result}\")\n    assert \"No files in safe directory\" in result, \"Empty safe/ list failed\"\n\n    # Test 9: Invalid file name\n    result = run_command(\"create file grok_local.py\")\n    print(f\"Invalid file name: {result}\")\n    assert \"Error: Invalid or protected filename\" in result, \"Invalid file name check failed\"\n\n    # Test 10: Auto-checkpoint on Git error (simulate no remote)\n    subprocess.run([\"git\", \"remote\", \"remove\", \"origin\"], capture_output=True)\n    result = run_command(\"git pull\", use_subprocess=True)\n    print(f\"Git pull error: '{result}'\")\n    assert \"git pull error\" in result.lower(), \"Git pull error not triggered\"\n    with open(os.path.join(PROJECT_DIR, \"checkpoint.json\"), \"r\") as f:\n        checkpoint = json.load(f)\n    assert \"git pull failed\" in checkpoint[\"description\"].lower(), \"Auto-checkpoint on Git error failed\"\n\n    # Restore remote with tracking and ensure it sticks\n    subprocess.run([\"git\", \"remote\", \"add\", \"origin\", \"git@github.com:imars/grok-local.git\"], capture_output=True)\n    subprocess.run([\"git\", \"branch\", \"--set-upstream-to=origin/main\", \"main\"], capture_output=True)\n    subprocess.run([\"git\", \"push\", \"--set-upstream\", \"origin\", \"main\"], capture_output=True)  # Ensure upstream is set\n\n    # Test 11: Prettier list_files\n    run_command(\"create file test2.txt\")\n    run_command(\"create file test3.txt\")\n    result = run_command(\"list files\")\n    print(f\"Pretty list files: {result}\")\n    assert \"1. test2.txt\" in result and \"2. test3.txt\" in result, \"Pretty list_files failed\"\n\n    # Test 12: Restore command\n    run_command(\"write Restored content to test2.txt\")\n    with open(os.path.join(PROJECT_DIR, \"grok.txt\"), \"w\") as f:\n        f.write(\"I am Grok, master of the repo\")\n    result = run_command(\"checkpoint Before restore test\")\n    print(f\"Checkpoint before restore: {result}\")\n    assert \"Checkpoint saved: Before restore test\" in result, \"Checkpoint before restore failed\"\n    shutil.rmtree(safe_dir)\n    with open(os.path.join(PROJECT_DIR, \"grok.txt\"), \"w\") as f:\n        f.write(\"Modified Grok text\")\n    result = run_command(\"restore\")\n    print(f\"Restore safe files: {result}\")\n    assert \"Restored files from checkpoint: test2.txt, test3.txt\" in result, \"Restore safe files failed\"\n    result = run_command(\"read file test2.txt\")\n    assert \"Restored content\" in result, \"Restore didn\u2019t reload safe file content\"\n    with open(os.path.join(PROJECT_DIR, \"grok.txt\"), \"r\") as f:\n        assert f.read() == \"Modified Grok text\", \"Restore shouldn\u2019t affect critical files without --all\"\n    result = run_command(\"restore --all\")\n    print(f\"Restore all files: {result}\")\n    assert \"grok.txt\" in result and \"test2.txt\" in result, \"Restore --all didn\u2019t reload all files\"\n    with open(os.path.join(PROJECT_DIR, \"grok.txt\"), \"r\") as f:\n        content = f.read()\n        print(f\"grok.txt content after restore --all: '{content}'\")\n        assert content == \"I am Grok, master of the repo\", \"Restore --all didn\u2019t reload critical file\"\n\n    # Test 13: Git diff\n    with open(os.path.join(PROJECT_DIR, \"grok.txt\"), \"w\") as f:\n        f.write(\"Grok has evolved!\")\n    result = run_command(\"git diff\")\n    print(f\"Git diff output: {result}\")\n    assert \"Grok has evolved!\" in result, \"Git diff failed to show changes\"\n    with open(os.path.join(PROJECT_DIR, \"grok.txt\"), \"w\") as f:\n        f.write(\"I am Grok, master of the repo\")\n\n    # Test 14: Restore from specific file\n    shutil.copy(os.path.join(PROJECT_DIR, \"checkpoint.json\"), os.path.join(PROJECT_DIR, \"checkpoint_backup.json\"))\n    run_command(\"write New content to test2.txt\")\n    run_command(\"create file test4.txt\")\n    result = run_command(\"checkpoint Modified state\")\n    print(f\"Checkpoint modified state: {result}\")\n    result = run_command(\"restore --file checkpoint_backup.json\")\n    print(f\"Restore from backup: {result}\")\n    assert \"test2.txt\" in result and \"test3.txt\" in result and \"test4.txt\" not in result, \"Restore --file didn\u2019t reload correct safe files\"\n    result = run_command(\"read file test2.txt\")\n    assert \"Restored content\" in result and \"New content\" not in result, \"Restore --file didn\u2019t revert content\"\n    result = run_command(\"restore --all --file checkpoint_backup.json\")\n    print(f\"Restore all from backup: {result}\")\n    assert \"grok.txt\" in result and \"test2.txt\" in result, \"Restore --all --file didn\u2019t reload all files\"\n\n    # Test 15: Checkpoint with specific file\n    run_command(\"write Custom content to test3.txt\")\n    result = run_command(\"checkpoint Custom backup --file custom_backup.json\")\n    print(f\"Checkpoint with file: {result}\")\n    assert \"Checkpoint saved: Custom backup to custom_backup.json\" in result, \"Checkpoint --file failed to save to specified file\"\n    with open(os.path.join(PROJECT_DIR, \"custom_backup.json\"), \"r\") as f:\n        checkpoint = json.load(f)\n    assert checkpoint[\"description\"] == \"Custom backup\", \"Checkpoint --file saved wrong description\"\n    assert \"test3.txt\" in checkpoint[\"safe_files\"] and checkpoint[\"safe_files\"][\"test3.txt\"] == \"Custom content\", \"Checkpoint --file didn\u2019t save correct safe file content\"\n\n    # Test 16: Autonomous file management\n    run_command(\"create file auto_file.txt\")\n    result = run_command(\"list files\")\n    file_count = len(result.splitlines())\n    if file_count > 3:  # Agent decides to clean up if too many files\n        result = run_command(\"delete file auto_file.txt --force && write Cleaned up to test2.txt\")\n        print(f\"Autonomous cleanup: {result}\")\n        assert \"Deleted file: auto_file.txt\" in result and \"Wrote to test2.txt: Cleaned up\" in result, \"Agent failed to clean up files\"\n    else:\n        result = run_command(\"write Keeping files to test2.txt\")\n        print(f\"Autonomous keep: {result}\")\n        assert \"Wrote to test2.txt: Keeping files\" in result, \"Agent failed to write decision\"\n\n    # Test 17: Git workflow\n    run_command(\"write Git test to test3.txt\")\n    result = run_command(\"git diff\")\n    if \"Git test\" in result:  # Agent decides to commit changes\n        result = run_command(\"commit Autonomous git commit\")\n        print(f\"Autonomous git commit: {result}\")\n        if \"Git error\" in result and \"no upstream branch\" in result:\n            # Agent adapts to missing upstream\n            subprocess.run([\"git\", \"push\", \"--set-upstream\", \"origin\", \"main\"], capture_output=True)\n            result = run_command(\"commit Autonomous git commit retry\")\n            print(f\"Autonomous git commit retry: {result}\")\n        assert \"Committed and pushed\" in result, \"Agent failed to commit changes after adapting\"\n    result = run_command(\"git diff\")\n    print(f\"Git diff after commit: {result}\")\n    assert \"No changes to display\" in result, \"Agent didn\u2019t clear git diff\"\n\n    # Test 18: Checkpoint management\n    run_command(\"checkpoint Initial state --file initial.json\")\n    run_command(\"write New state to test2.txt\")\n    result = run_command(\"list checkpoints\")\n    print(f\"List checkpoints: {result}\")\n    if \"initial.json\" in result:  # Agent decides to restore if backup exists\n        result = run_command(\"restore --file initial.json\")\n        print(f\"Autonomous restore: {result}\")\n        assert \"test2.txt\" in result and \"New state\" not in run_command(\"read file test2.txt\"), \"Agent failed to restore checkpoint\"\n    else:\n        result = run_command(\"checkpoint No backups found\")\n        print(f\"Autonomous checkpoint: {result}\")\n        assert \"Checkpoint saved: No backups found\" in result, \"Agent didn\u2019t save fallback checkpoint\"\n\n    print(\"All tests passed!\")\n\nif __name__ == \"__main__\":\n    test_sequence()\n",
        "README.md": "# grok-local\n\nWelcome to *grok-local*, a badass local agent that wrangles your GitHub repo with file and Git ops, powered by Deepseek-R1 or Llama3.2. It\u2019s built to run solo or sync up with remote agents like Grok 3, our fearless project lead.\n\n## Overview\n- **Core**: `grok_local.py`\u2014the brain, dishing out CLI commands for file ops, Git ops, and checkpoints.\n- **File Ops**: Locked in `safe/`\u2014create, delete (with `--force`), move, copy, rename, read, write, list (now with prettier numbered output).\n- **Git Ops**: Repo mastery\u2014status, pull, log, branch, checkout, commit, remove, and now `diff` to see changes.\n- **Checkpointing**: Snapshots save critical files and `safe/` contents to `checkpoint.json` or custom files with `--file`. Restore from any checkpoint with `restore --file`.\n- **Tests**: `tests/test_grok_local.py`\u201415 rock-solid tests covering all features, including `restore --file` and `checkpoint --file`.\n\n## Setup\n1. **Clone it**: `git clone git@github.com:imars/grok-local.git`\n2. **Gear up**: `pip install gitpython`\n3. **Launch**: `python grok_checkpoint.py` (interactive) or `python grok_checkpoint.py --ask \"command\"`\n\n## Usage\n- **Interactive Mode**: `python grok_checkpoint.py`\n  - Prompt: `Command:`\n  - Try: `create file test.txt`, `git status`, `checkpoint Adding a test file`\n- **One-Shot**: `python grok_checkpoint.py --ask \"list files\"`\n- **Resume**: `python grok_checkpoint.py --resume`\u2014see the last checkpoint.\n- **Examples**:\n  - `write Hello to test.txt && commit Updated test.txt`\n  - `delete file test.txt --force`\n  - `git diff`\n  - `checkpoint My backup --file backup.json`\n  - `restore --file backup.json`\n  - `restore --all --file backup.json`\n\n## Checkpoint System\n- **What It Does**: Captures the project\u2019s soul\u2014critical files, `safe/` files, and a description\u2014to keep you (or a new agent) in the loop.\n- **Save It**: `checkpoint <description>` or `checkpoint <description> --file <filename>` (e.g., `checkpoint My backup --file my_backup.json`).\n- **Restore It**: `restore` (safe files only), `restore --all` (all files), or `restore --file <filename>`/`restore --all --file <filename>` to roll back from any checkpoint.\n- **Peek**: `--resume` shows the latest snapshot, including tracked files and `safe/` contents.\n- **Tracked Files**: `grok_local.py`, `file_ops.py`, `git_ops.py`, `grok_checkpoint.py`, `.gitignore`, `grok.txt`, `tests/test_grok_local.py`, `README.md`\n\n## Current State\nAs of February 27, 2025:\n- **Features**: Prettier `list_files`, `restore --all`, `git diff`, `restore --file`, and `checkpoint --file`\u2014all tested and committed.\n- **`safe/`**: Holds `test2.txt`, `test3.txt`, `plan_v1.txt`, `renamed.txt`, `plan_original.txt`.\n- **Tests**: 15 passing tests in `test_grok_local.py`, covering file ops, Git ops, and checkpoint/restore functionality.\n- **Lead**: Grok 3, steering the ship with xAI\u2019s finest.\n\n## Development\n- **Next Up**: Maybe a `list checkpoints` command or more test edge cases?\n- **Contribute**: Fork, tweak, PR\u2014let\u2019s keep this beast evolving!\n"
    },
    "safe_files": {
        "plan_v1.txt": "",
        "renamed.txt": "",
        "plan_original.txt": ""
    }
}