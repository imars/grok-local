It sounds like you're making great progress with grok-local! Your project is an interesting blend of local AI agent capabilities (using Deepseek-R1 or Llama3.2) and integration with GitHub and Grok 3 via X. The issue you're facing with headless mode and cookie persistence is a common challenge when automating browser interactions with Selenium. Let’s dive into your problem and see how we can improve cookie handling to stabilize headless mode.Analyzing the Headless Mode Cookie IssueFrom your description and the code in x_poller.py, the cookies are being saved to cookies.pkl after a manual login, and you're attempting to reuse them in headless mode. However, it seems like either the cookies aren't being fully saved, aren't being correctly loaded, or are insufficient for authentication in headless mode due to differences in browser behavior (e.g., missing JavaScript execution, stricter security policies, or session validation).Here’s a breakdown of potential issues and solutions:Incomplete Cookie Saving:The current code saves cookies after navigating to GROK_URL and handling consent (pickle.dump(driver.get_cookies(), open(COOKIE_FILE, "wb"))). However, if the session requires additional cookies set earlier (e.g., during login or consent), they might be missed.Fix: Save cookies immediately after the full login process, before navigating to GROK_URL.Headless Mode Differences:Headless Chrome might not handle JavaScript-driven cookie setting or redirects the same way as a visible browser, leading to invalid sessions.Fix: Ensure the headless browser mimics a real user session with appropriate user-agent and options, and double-check cookie domain/path compatibility.Cookie Validation:The cookies_valid() function checks if "Grok" is in the title and "Login" isn’t, but this might not fully confirm authentication (e.g., if the page partially loads).Fix: Add a more robust check, like looking for a specific authenticated element on the page.File Access in Headless Mode:If cookies.pkl isn’t being read/written correctly due to filesystem issues in headless environments (e.g., containerized setups), this could break the flow.Fix: Log file operations explicitly to confirm they succeed.Proposed SolutionLet’s modify x_poller.py to improve cookie handling and add better logging for debugging in headless mode. I’ll also suggest a few tweaks to make it more robust. Since you’re using a CLI and prefer cat commands for file output, I’ll present the updated file that way.Updated x_poller.pybashcat << 'EOF' > x_poller.py
import requests
import os
import pickle
from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.chrome.options import Options
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
import time
import json
import logging
import subprocess
from logging.handlers import RotatingFileHandler

PROJECT_DIR = os.getcwd()
GROK_URL = "https://x.com/i/grok?conversation=1894190038096736744"
COOKIE_FILE = os.path.join(PROJECT_DIR, "cookies.pkl")

logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s - %(message)s",
    handlers=[RotatingFileHandler("x_poller.log", maxBytes=1*1024*1024, backupCount=3)]
)

def handle_cookie_consent(driver, wait):
    try:
        consent_button = wait.until(EC.element_to_be_clickable((By.XPATH, "//button[contains(text(), 'Allow') or contains(text(), 'Accept')]")))
        consent_button.click()
        logging.info("Clicked cookie consent button")
        time.sleep(2)
        return True
    except:
        logging.info("No cookie consent button found")
        return False

def cookies_valid(driver):
    driver.get(GROK_URL)
    time.sleep(5)
    logging.info(f"Checking cookies - Title: {driver.title}")
    try:
        wait = WebDriverWait(driver, 10)
        wait.until(EC.presence_of_element_located((By.CLASS_NAME, "r-30o5oe")))  # Prompt box as auth indicator
        return True
    except:
        return False

def save_cookies(driver):
    cookies = driver.get_cookies()
    with open(COOKIE_FILE, "wb") as f:
        pickle.dump(cookies, f)
    logging.info(f"Saved {len(cookies)} cookies to {COOKIE_FILE}")

def load_cookies(driver):
    if not os.path.exists(COOKIE_FILE):
        logging.info("No cookie file found")
        return False
    with open(COOKIE_FILE, "rb") as f:
        cookies = pickle.load(f)
    driver.delete_all_cookies()
    for cookie in cookies:
        try:
            driver.add_cookie(cookie)
        except Exception as e:
            logging.warning(f"Failed to add cookie {cookie.get('name')}: {e}")
    logging.info(f"Loaded {len(cookies)} cookies")
    return True

def ask_grok(prompt, fetch=False, headless=False):
    logging.info(f"ask_grok called - prompt: {prompt}, fetch: {fetch}, headless: {headless}")
    chrome_options = Options()
    if headless:
        chrome_options.add_argument("--headless")
        chrome_options.add_argument("--no-sandbox")
        chrome_options.add_argument("--disable-dev-shm-usage")
        chrome_options.add_argument("--disable-gpu")
        chrome_options.add_argument("user-agent=Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36")
    driver = webdriver.Chrome(options=chrome_options)
    wait = WebDriverWait(driver, 60)

    # Try loading cookies first in headless mode
    driver.get("https://x.com")  # Start at root to set domain context
    if headless and load_cookies(driver):
        driver.get(GROK_URL)
        time.sleep(5)
        if cookies_valid(driver):
            logging.info("Cookies valid, proceeding with interaction")
            return process_grok_interaction(driver, wait, prompt, fetch)
        else:
            logging.info("Cookies invalid, falling back to login")

    # Login process
    driver.get("https://x.com/login")
    if not headless:
        input("Log in with @ianatmars, then press Enter: ")
    else:
        logging.info("Headless login not implemented yet, manual login required")
        driver.quit()
        return "Headless login not supported yet"

    handle_cookie_consent(driver, wait)
    
    try:
        verify_input = wait.until(EC.visibility_of_element_located((By.XPATH, "//input[@name='text']")))
        verify_value = input("Enter phone or email: ") if not headless else "YOUR_PHONE_OR_EMAIL"
        verify_input.send_keys(verify_value)
        next_button = wait.until(EC.element_to_be_clickable((By.XPATH, "//span[text()='Next']")))
        next_button.click()
        time.sleep(5)
    except:
        logging.info("No verification step required")

    # Save cookies after successful login
    save_cookies(driver)
    driver.get(GROK_URL)
    time.sleep(5)
    if handle_cookie_consent(driver, wait):
        time.sleep(2)

    return process_grok_interaction(driver, wait, prompt, fetch)

def process_grok_interaction(driver, wait, prompt, fetch):
    if fetch:
        elements = driver.find_elements(By.CSS_SELECTOR, "[data-testid='markdown-code-block']")
        logging.info(f"Total elements found: {len(elements)}")
        for i, elem in enumerate(elements):
            text = elem.get_attribute("textContent")
            logging.info(f"Element {i}: {text}")
            if "GROK_LOCAL:" in text:
                cmd = text.replace("GROK_LOCAL:", "").strip()
                logging.info(f"Found command: {cmd}")
                driver.quit()
                return cmd
        driver.quit()
        return "No GROK_LOCAL found after full scan"
    else:
        prompt_box = wait.until(EC.visibility_of_element_located((By.CLASS_NAME, "r-30o5oe")))
        prompt_box.clear()
        prompt_box.send_keys(prompt)
        submit_button = wait.until(EC.element_to_be_clickable((By.CLASS_NAME, "css-175oi2r")))
        submit_button.click()
        time.sleep(15)
        initial_count = len(driver.find_elements(By.CSS_SELECTOR, "[data-testid='markdown-code-block']"))
        response_elements = wait.until(
            lambda driver: [
                elem.find_element(By.TAG_NAME, "pre")
                for elem in driver.find_elements(By.CSS_SELECTOR, "[data-testid='markdown-code-block']")[initial_count:]
                if elem.get_attribute("textContent")
            ]
        )
        driver.quit()
        return response_elements[-1].get_attribute("textContent")

def poll_x(headless):
    while True:
        cmd = ask_grok("Polling for Grok 3...", fetch=True, headless=headless)
        if cmd and "Cookie" not in cmd and "Failed" not in cmd:
            print(f"Received: {cmd}")
            if cmd.startswith("ask "):
                result = subprocess.run(
                    ["python", "grok-local.py", "--ask", cmd[4:]],
                    capture_output=True, text=True
                )
                print(f"Result: {result.stdout}")
                ask_grok(f"GROK_LOCAL_RESULT: {result.stdout}", headless=headless)
            else:
                print("Unknown command format")
        else:
            print(f"Poll failed: {cmd}")
        time.sleep(30)

if __name__ == "__main__":
    import argparse
    parser = argparse.ArgumentParser(description="Poll X for Grok 3 commands")
    parser.add_argument("--headless", action="store_true")
    args = parser.parse_args()
    poll_x(args.headless)
EOFKey ChangesDedicated Cookie Functions:Added save_cookies() and load_cookies() to centralize cookie management and log their success/failure.Cookies are now saved right after login, before navigating to GROK_URL, to capture the full session.Improved Cookie Validation:cookies_valid() now checks for the presence of the prompt box (.r-30o5oe) as a stronger indicator of being logged in, rather than just the page title.Headless Mode Cookie Loading:In headless mode, the script starts at https://x.com to set the domain context before loading cookies, then refreshes after applying them.Better Logging:Added logging for cookie loading/saving counts and individual cookie errors to help diagnose issues.Driver Cleanup:Ensured driver.quit() is called in all process_grok_interaction() paths to avoid resource leaks.Testing and DebuggingManual Test: Run without --headless first to generate a fresh cookies.pkl. Verify it works by checking the logs (x_poller.log) for "Cookies valid, proceeding".Headless Test: Run with --headless and monitor the logs. If it fails, look for cookie-related errors or invalid session indicators.Cookie Inspection: After saving cookies, you can manually inspect cookies.pkl (e.g., with a Python script) to ensure all expected cookies (like auth_token, ct0) are present.Next StepsHeadless Login: You mentioned headless login isn’t implemented. If you want to fully automate this, you’d need to store credentials securely (e.g., in an environment variable or keyring) and simulate the login form submission.Cookie Expiry: X might invalidate cookies periodically. Add logic to detect this (e.g., repeated "Cookies invalid" logs) and fall back to a login flow.Robustness: Test with a clean slate (delete cookies.pkl) to ensure the fallback to login works in headless mode once implemented.Let me know how this works or if you’d like to refine it further! I can also help with optimizing grok-local.py or integrating it more tightly with GitHub if you’d like. What’s your next focus for the project?